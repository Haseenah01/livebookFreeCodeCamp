# Data Types

## Atoms

```elixir
:error
```

```elixir
{:error, reason} = {:error, "file not found"}
reason
```

```elixir
{:ok, msg} = {:ok, "status 200 ok"}
msg
```

## Strings

```elixir
name = "Haseenah"
name
```

```elixir
is_binary(name)
```

```elixir
msg = "Hello " <> name
```

```elixir
"Hello " <> name = msg
name
```

```elixir
<<head, rest::binary>> = name
head
```

```elixir
head == ?H
```

```elixir
<<"H", rest::binary>> = name
rest
```

```elixir
<<"Ha", rest::binary>> = name
rest
```

```elixir
<<head::binary-size(2), rest::binary>> = name
head
```

## Charlist

```elixir
chars = 'Haseenah'
```

```elixir
'Hello ' ++ chars
```

```elixir
is_list(chars)
```

```elixir
?H
```

## Process

```elixir
my_pid = self()
my_pid
```

## Lists Are Not Lists- They are Linked Lists!

```elixir
lists = ["a", "b", "c"]
```

```elixir
Enum.at(lists, 0)
```

```elixir
[first, second, third] = lists
second
```

```elixir
[_, _, third] = ["a", "b", "c"]
third
```

```elixir
hd(lists)
```

```elixir
tl(lists)
```

```elixir
[h | t] = lists
h
```

```elixir
t
```

## Tuple

```elixir
{a, b} = {1, 2}
a
```

```elixir
{:reply, msg, state} = {:reply, "Haseenah found!", ["Haseenah", "Azhar", "Taslimah"]}
state
```

## Keyword List

```elixir
data = [a: 1, b: 2]
```

```elixir
[{:a, 1}] = [a: 1]
```

```elixir
data[:b]
```

## Maps

```elixir
my_map = %{a: 1, b: 2, c: 3}
my_map
```

```elixir
%{a: first, b: second, c: third} = my_map
third
```

```elixir
%{b: second} = my_map
second
```

```elixir
my_map.c
```

```elixir
map2 = %{"a" => 1, "b" => 2, "c" => 3}
```

```elixir
%{"b" => b} = map2
b
```

```elixir
map2 = %{map2 | "b" => 5}
```

```elixir
my_map = %{my_map | a: 6}
```

## Struct

```elixir
defmodule User do
  defstruct username: "", email: "", age: nil
end
```

```elixir
user1 = %User{username: "Haseenah", email: "haseenahsami10@gmail.com", age: 22}
```

```elixir
%{email: email} = user1
email
```

```elixir
user1 = %{user1 | username: "Sami"}
```

## Head recursion

```elixir
defmodule Tutorials.Recursion.PrintDigits do
  # Base Case
  def upto(0), do: 0

  # recursive case
  def upto(nums) do
    # 3 , 2 , 1 ,
    upto(nums - 1)
    IO.puts(nums)
  end
end
```

```elixir
printNumbers = Tutorials.Recursion.PrintDigits.upto(5)
```

## Tail recursion

```elixir
defmodule Tutorials.TRecursion.PrintDigits do
  # Base Case
  def upto(0), do: 0

  # recursive case
  def upto(nums) do
    # 3 , 2 , 1 ,
    IO.puts(nums)
    upto(nums - 1)
  end
end
```

```elixir
print = Tutorials.TRecursion.PrintDigits.upto(5)
```

## Sum digits- Regular recursion function

```elixir
defmodule Tutorials.Recursion.SumDigits do
  def upto(0), do: 0

  def upto(num) do
    num + upto(num - 1)
  end
end
```

```elixir
sum = Tutorials.Recursion.SumDigits.upto(3)
```

## Sum Digits - Tail recursion

```elixir
defmodule Tutorials.TRecursion.SumDigits do
  def upto(0), do: 0

  def upto(num) do
    num + upto(num - 1)
  end

  def upto_tail_rec(num, acc \\ 0)
  def upto_tail_rec(0, acc), do: acc

  def upto_tail_rec(num, acc) do
    upto_tail_rec(num - 1, acc + num)
  end
end
```

```elixir
result = Tutorials.TRecursion.SumDigits.upto_tail_rec(4)
```
