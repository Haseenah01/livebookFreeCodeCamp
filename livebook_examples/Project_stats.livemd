# Project Stats

## Error

```elixir
defmodule Stats.Errors do
  @spec invalid_data_type() :: {atom(), String.t()}
  def invalid_data_type, do: {:error, "Invalid data type"}
end
```

## Validate

```elixir
defmodule Stats.Validators do
  alias Stats.Errors

  @spec validate_num_list([number()]) :: {boolean(), [number()]} | {atom(), String.t()}
  def validate_num_list(nums) when is_list(nums) do
    {Enum.all?(nums, fn el -> is_number(el) end), nums}
  end

  def validate_num_list(_), do: Errors.invalid_data_type()
end
```

## Mean

```elixir
defmodule Stats.CentralTendency.Mean do
  alias Stats.{Errors, Validators}
  # alias Stats.Validators
  # sum (sigma) / count

  @spec population_mean([number()]) :: number() | {atom(), String.t()}
  def population_mean([]), do: Errors.invalid_data_type()

  def population_mean(nums) when is_list(nums) do
    nums
    |> Validators.validate_num_list()
    |> calc_population_mean()
  end

  def population_mean(_), do: Errors.invalid_data_type()

  # ------------------------------------------------------------------------------------------

  @spec sample_mean([number()]) :: number() | {atom(), String.t()}
  def sample_mean(nums), do: population_mean(nums)

  # ------------------------------------------------------------------------------------------
  defp calc_population_mean({false, _}), do: Errors.invalid_data_type()

  defp calc_population_mean({true, nums}) do
    nums
    |> Enum.sum()
    |> mean(Enum.count(nums))
  end

  # ------------------------------------------------------------------------------------------

  defp mean(sigma, count), do: sigma / count
end
```

```elixir
alias Stats.CentralTendency.Mean
Mean.population_mean([10, 20, 30])
```

```elixir
Mean.population_mean([])
```

```elixir
Mean.population_mean("abc")
```

```elixir
Mean.sample_mean([10, 20, 30])
```

## Median

```elixir
defmodule Stats.CentralTendency.Median do
  require Integer
  alias Stats.Errors
  alias Stats.Validators

  def median(num_list) when is_list(num_list) do
    num_list
    |> Validators.validate_num_list()
    |> calc_median()
  end

  def median(_), do: Errors.invalid_data_type()

  # -----------------------------------------------------

  defp calc_median({:error, _msg}), do: Errors.invalid_data_type()
  defp calc_median({false, _}), do: Errors.invalid_data_type()

  defp calc_median({true, num_list}) do
    count = num_list |> Enum.count()

    num_list
    |> Enum.sort()
    |> get_median(Integer.is_even(count), count)
  end

  # ------------------------------------------------------

  defp get_median(num_list, false, count), do: Enum.at(num_list, div(count, 2))

  defp get_median(num_list, true, count) do
    a = Enum.at(num_list, div(count - 1, 2))
    b = Enum.at(num_list, div(count, 2))

    (a + b) / 2
  end
end
```

## Mode

```elixir
ranked_map = [1, 2, 3, 4, 5, 4, 5, 2, 8, 9, 8, 6, 8, 4] |> Enum.frequencies()
```

```elixir
max = ranked_map |> Map.values() |> Enum.max()
```

```elixir
ranked_map |> Map.filter(fn {_key, value} -> value == max end)
```

```elixir
ranked_map |> Map.filter(fn {_key, value} -> value == max end) |> Map.keys()
```

```elixir
defmodule Stats.CentralTendency.Mode do
  def mode(nums) when is_list(nums) do
    ranked_map = nums |> Enum.frequencies()

    ranked_map
    |> Map.values()
    |> Enum.max()
    |> mode_func(ranked_map)
  end

  defp mode_func(1, _ranked_map), do: nil

  defp mode_func(max, ranked_map) do
    ranked_map
    |> Map.filter(fn {_key, value} -> value == max end)
    |> Map.keys()
  end
end
```

## Stats

```elixir
defmodule Stats do
  alias Stats.CentralTendency.{Mean, Median, Mode}

  # def population_mean(nums), do: Mean.population_mean(nums)
  @spec population_mean([number]) :: float | {:error, <<_::136>>}
  # does the same thing as above function
  defdelegate population_mean(nums), to: Mean

  @spec sample_mean([number]) :: float | {:error, <<_::136>>}
  defdelegate sample_mean(nums), to: Mean

  @spec median(any) :: any
  defdelegate median(num_list), to: Median

  @spec mode(maybe_improper_list) :: nil | list
  defdelegate mode(num_list), to: Mode
end
```

```elixir
Stats.population_mean([10, 20, 30])
```

```elixir
Stats.sample_mean([3, 4, 5, 6, 7])
```

```elixir
Stats.median([10, 40, 20, 50, 30, 70, 60, 80])
```

```elixir
Stats.median([10, 40, 20, 50, 30, 90, 70, 60, 80])
```

```elixir
Stats.mode([1, 2, 3, 4, 5, 4, 5, 2, 8, 9, 8, 6, 8, 4])
```
